<!DOCTYPE html>


  <html class="light page-post">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>JS中面向对象 | INTROSPECTION MOMENT</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="前端,前端开发,nodejs,JavaScript">
  

  <meta name="description" content="理解对象属性什么是对象 无序属性的集合，其属性可以包含基本值、对象或者函数。对象是一组没有特定顺序的值，对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。每个对象都是基于一个引用类型创建的。面向对象特点：封装、多态、继承  创建对象 最简单的方式就是创建一个object的实例，然后为它添加属性和方法  12345678910111213141516let person = new Obj">
<meta property="og:type" content="article">
<meta property="og:title" content="JS中面向对象">
<meta property="og:url" content="http://janely.cn/2018/12/09/js/oop/index.html">
<meta property="og:site_name" content="INTROSPECTION MOMENT">
<meta property="og:description" content="理解对象属性什么是对象 无序属性的集合，其属性可以包含基本值、对象或者函数。对象是一组没有特定顺序的值，对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。每个对象都是基于一个引用类型创建的。面向对象特点：封装、多态、继承  创建对象 最简单的方式就是创建一个object的实例，然后为它添加属性和方法  12345678910111213141516let person = new Obj">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://blog-githb.oss-cn-beijing.aliyuncs.com/prototype.png">
<meta property="og:updated_time" content="2019-12-25T08:38:58.533Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS中面向对象">
<meta name="twitter:description" content="理解对象属性什么是对象 无序属性的集合，其属性可以包含基本值、对象或者函数。对象是一组没有特定顺序的值，对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。每个对象都是基于一个引用类型创建的。面向对象特点：封装、多态、继承  创建对象 最简单的方式就是创建一个object的实例，然后为它添加属性和方法  12345678910111213141516let person = new Obj">
<meta name="twitter:image" content="https://blog-githb.oss-cn-beijing.aliyuncs.com/prototype.png">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  

  


  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">菜单</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">菜单</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#理解对象属性"><span class="toc-text">理解对象属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是对象"><span class="toc-text">什么是对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象"><span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性类型"><span class="toc-text">属性类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据属性"><span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperty-修改数据属性"><span class="toc-text">Object.defineProperty()修改数据属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问器属性"><span class="toc-text">访问器属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperty-定义访问器属性"><span class="toc-text">Object.defineProperty()定义访问器属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义多个属性"><span class="toc-text">定义多个属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象-1"><span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、工厂模式"><span class="toc-text">1、工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、构造函数模式"><span class="toc-text">2、构造函数模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是构造函数"><span class="toc-text">什么是构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、原型模式"><span class="toc-text">3、原型模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合模式"><span class="toc-text">组合模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原型链"><span class="toc-text">原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链搜索机制"><span class="toc-text">原型链搜索机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链的问题"><span class="toc-text">原型链的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#借用构造函数"><span class="toc-text">借用构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#传递参数"><span class="toc-text">传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#借用构造函数的问题"><span class="toc-text">借用构造函数的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合继承"><span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型式继承Object-create"><span class="toc-text">原型式继承Object.create()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄生式继承"><span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄生组合式继承"><span class="toc-text">寄生组合式继承</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article 
  id="post-js/oop" 
  class="article article-type-post" 
  itemprop="blogPost"
  style="margin-bottom: 10vh;">
  <header class="article-header">
    <h1 class="post-title">JS中面向对象</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.12.09</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Janely</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Javascript/">Javascript</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="理解对象属性"><a href="#理解对象属性" class="headerlink" title="理解对象属性"></a>理解对象属性</h1><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><blockquote>
<p><strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>。对象是一组没有特定顺序的值，对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。每个对象都是基于一个引用类型创建的。<strong>面向对象特点：封装、多态、继承</strong></p>
</blockquote>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ul>
<li>最简单的方式就是创建一个object的实例，然后为它添加属性和方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">'jane'</span></span><br><span class="line">person.age = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象字面量语法重构：</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'jane'</span>,</span><br><span class="line">  age: <span class="number">25</span></span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><blockquote>
<p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。有4个描述其行为的特性：</p>
</blockquote>
<ul>
<li><p><code>[[Configurable]]</code>：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，默认值是true</p>
</li>
<li><p><code>[[Enumerable]]</code>：表示能否通过for-in循环属性，默认值是true</p>
</li>
<li><p><code>[[Writable]]</code>：表示能否修改属性的值，默认值是true</p>
</li>
<li><p><code>[[Value]]</code>：包含这个属性的数据值。从这个位置读，写入属性值时把新的值保存在这个位置，默认值为undefined</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[Value]]特性被设定为指定的值，如：</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'jane'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-defineProperty-修改数据属性"><a href="#Object-defineProperty-修改数据属性" class="headerlink" title="Object.defineProperty()修改数据属性"></a>Object.defineProperty()修改数据属性</h3><blockquote>
<p>要修改上面属性默认的特性，必须使用Object.defineProperty()方法。</p>
</blockquote>
<p><strong>三个参数：</strong></p>
<ul>
<li>属性所在的对象</li>
<li>属性的名字</li>
<li>一个描述符对象：其属性必须是：configurable、enumerable、writable、value</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把person的name属性改为只读。</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// name属性为只读</span></span><br><span class="line">  value: <span class="string">'jane'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 'jane'</span></span><br><span class="line">person.name = <span class="string">'symbol'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 'jane'</span></span><br></pre></td></tr></table></figure>

<p><strong>可以多次调用Object.defineProperty()修改同一个属性，但在把configurable特性设置为false后就会有限制</strong></p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><blockquote>
<p>不包含数据值，包含getter和setter函数（这两个函数都不是必须的）。</p>
</blockquote>
<ul>
<li>getter函数：读取访问器属性，返回有效的值</li>
<li>setter函数：写入访问器属性，传入新值，负责决定如何处理数据。</li>
</ul>
<p><strong>四个特性</strong></p>
<ul>
<li><p><code>[[Configurable]]</code>：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，默认值是true</p>
</li>
<li><p><code>[[Enumerable]]</code>：表示能否通过for-in循环属性，默认值是true</p>
</li>
<li><p><code>[[Get]]</code>：在读取属性时调用函数，默认值是undefeated</p>
</li>
<li><p><code>[[Set]]</code>：在写入属性时调用函数，默认值是undefeated</p>
</li>
</ul>
<h3 id="Object-defineProperty-定义访问器属性"><a href="#Object-defineProperty-定义访问器属性" class="headerlink" title="Object.defineProperty()定义访问器属性"></a>Object.defineProperty()定义访问器属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  _year: <span class="number">2018</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'year'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="keyword">this</span>._year) &#123;</span><br><span class="line">      <span class="keyword">this</span>.age += newValue - <span class="keyword">this</span>._year</span><br><span class="line">      <span class="keyword">this</span>._year = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.year = <span class="number">2019</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>使用Object.defineProperties()方法可以通过描述符一次定义多个属性。参数：</p>
<ul>
<li>要添加和修改其属性的对象</li>
<li>与第一个对象中要添加或修改的属性一一对应</li>
</ul>
<p>Object.defineProperties()和Object.defineProperty唯一的区别是：<strong>Object.defineProperties()定义的属性都是同一时间创建的</strong></p>
<h2 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="1、工厂模式"><a href="#1、工厂模式" class="headerlink" title="1、工厂模式"></a>1、工厂模式</h3><blockquote>
<p>使用同一个接口创建很多对象，会产生大量的重复代码。为了解决这个问题，开始使用工厂模式的一种变体。抽象了创建具体对象的过程。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age </span><br><span class="line">  o.job = job</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  retrun o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">'jane'</span>, <span class="number">25</span>, <span class="string">'teacher'</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">'symbol'</span>, <span class="number">30</span>, <span class="string">'doctor'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2、构造函数模式"><a href="#2、构造函数模式" class="headerlink" title="2、构造函数模式"></a>2、构造函数模式</h3><blockquote>
<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎么知道一个对象的类型），为了解决这个问题，构造函数模式出现。</p>
</blockquote>
<h4 id="什么是构造函数"><a href="#什么是构造函数" class="headerlink" title="什么是构造函数"></a>什么是构造函数</h4><blockquote>
<p>用 new 关键字来调用的函数，称为构造函数。</p>
</blockquote>
<ul>
<li>构造函数可以用来创建特定类型的对象，原生构造函数在运行时会自动出现在执行环境中</li>
<li>可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法</li>
<li>可以将实例标识为一种特定的类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.obj = obj</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'jane'</span>, <span class="number">25</span>, <span class="string">'teacher'</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'symbol'</span>, <span class="number">30</span>, <span class="string">'doctor'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造函数经历的过程：</span></span><br><span class="line">- 创建一个新对象</span><br><span class="line">- 将构造函数的作用域赋值给新对象</span><br><span class="line">- 执行构造函数中的代码</span><br><span class="line">- 返回新对象</span><br></pre></td></tr></table></figure>

<p><strong>工厂模式和构造函数模式的区别</strong></p>
<ul>
<li>没有显示地创建对象</li>
<li>没有return语句</li>
<li>直接将属性和方法赋值给了this对象</li>
<li>构造函数以一个大写字母开头，非构造函数以小写字母开头</li>
</ul>
<p><strong>constructor</strong></p>
<blockquote>
<p>用来标识对象类型</p>
</blockquote>
<ul>
<li>person1和person2分别保存着Person的一个不同的实例，这两个对象都有一个constructor属性，该属性指向Person。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.constructor === Person) <span class="comment">// true</span></span><br><span class="line">alert(person2.constructor === Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数的问题</strong></p>
<ul>
<li>每个方法都要在每个实例上重新创建一遍。</li>
<li>这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例但机制仍然是相同但</li>
<li>不同实例上同名函数是不相等的</li>
<li>虽然可以将函数定义在构造函数外部，内部的函数等于全局的函数，但是在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实</li>
<li>如果对象需要定义很多方法，那么就要定义很多个全局函数</li>
</ul>
<h3 id="3、原型模式"><a href="#3、原型模式" class="headerlink" title="3、原型模式"></a>3、原型模式</h3><blockquote>
<p>基于上述构造函数的问题，为了解决这些问题，可以使用原型模式。《高级程序设计》里提到我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按字面意思解释，prototype就是通过该构造函数创建的某个实例的原型对象，但是其实prototype是每个构造函数的属性而已，只能说万物皆对象罢了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'jane'</span></span><br><span class="line">Person.prototype.age = <span class="number">25</span></span><br><span class="line">Person.prototype.sex = <span class="string">'male'</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.sayName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person2.sayName()</span><br><span class="line"></span><br><span class="line"><span class="comment">// person1.sayName === person2.sayName</span></span><br></pre></td></tr></table></figure>

<p><strong>原型对象、构造函数、实例三者之间的关系</strong></p>
<p><img src="https://blog-githb.oss-cn-beijing.aliyuncs.com/prototype.png" alt></p>
<ul>
<li>构造函数：普通函数通过new调用时就称为构造函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> = </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'jane'</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例：通过构造函数的new操作创建的对象是实例对象，实例通过内部属性(<em>proto</em>)指向原型对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person1就是实例</span></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure>

<ul>
<li>原型对象：任何一个函数，都拥有一个prototype属性，指向其原型对象，该原型对象也是由该函数new调用创造的所有实例对象的原型对象。原型对象的construct属性指向的是构造函数，prototype等价于<strong>proto</strong>。</li>
</ul>
<p><strong>Person.prototype只是一个指针，指向函数的原型对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.construct === Person <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p>组合使用构造函数模式和原型模式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sex = sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'jane'</span>, <span class="number">25</span>, <span class="string">'man'</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'symbol'</span>, <span class="number">30</span>, <span class="string">'man'</span>)</span><br><span class="line">person1.job = <span class="string">'developer'</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.job) <span class="comment">// 'developer'</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.job) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.job === person2.job) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote>
<p>由于函数没有签名，在js中无法实现接口继承，只支持实现继承，而且实现继承主要是依靠原型链来实现的。</p>
</blockquote>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><blockquote>
<p>利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<p><strong>构造函数、原型、实例的关系：</strong></p>
<ul>
<li><p>每一个构造函数都有一个原型对象</p>
</li>
<li><p>原型对象都包含一个指向构造函数的指针</p>
</li>
<li><p>实例都包含一个指向原型对象的内部指针。</p>
</li>
</ul>
<p><strong>假如让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，形成所谓的原型链</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance =  <span class="keyword">new</span> SubType()</span><br><span class="line"></span><br><span class="line">alert(instance.getSuperValue()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链搜索机制"><a href="#原型链搜索机制" class="headerlink" title="原型链搜索机制"></a>原型链搜索机制</h3><blockquote>
<p>当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。</p>
</blockquote>
<p><strong>上述代码中调用instance.getSuperValue()的过程</strong></p>
<ol>
<li>搜索实例</li>
<li>搜索SubType.prototype</li>
<li>搜索SuperType.prototype</li>
</ol>
<p><strong>实际上，不是SubType的原型的constructor属性被重写了，而是SubType的原型指向另一个对象SuperType的原型，而这个原型对象的constrctor属性指向的是SuperType</strong></p>
<p><strong>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针指向Object.prototype</strong></p>
<h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><ul>
<li>最主要的问题来自包含引用类型值的原型属性会被所有实例共享</li>
<li>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instacne1.colors) <span class="comment">// ['red', 'blue', 'black']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType() </span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors) <span class="comment">// ['red', 'blue', 'black']</span></span><br></pre></td></tr></table></figure>

<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><blockquote>
<p>为了解决包含引用类型值的原型属性会被所有实例共享的问题，开发了借用构造函数继承（伪造对象或经典继承），即在子类型构造函数的内部调用超类型构造函数。</p>
</blockquote>
<p><strong>函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call方法也可以在（将来）新创建的对象上执行构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承 SuperType</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instacne1.colors) <span class="comment">// ['red', 'blue', 'black']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType() </span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors) <span class="comment">// ['red', 'blue']</span></span><br></pre></td></tr></table></figure>

<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><blockquote>
<p>借用构造函数有一个很大的又是，即可以在子类型构造函数中向超类型构造函数传递参数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承 SuperType</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">'jane'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType() </span><br><span class="line"><span class="built_in">console</span>.log(instance.name) <span class="comment">// 'jane'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<h3 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h3><ul>
<li>无法避免构造函数模式存在的问题 ——— 方法都在构造函数中定义，因此函数复用就不能实现。在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。</li>
</ul>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote>
<p>将原型链和借用构造函数的技术组合一起。思路是：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现来函数的复用，又能够保证每个实例都有它自己的属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">'jane'</span>)  <span class="comment">// 第二次调用超类型继承</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType() <span class="comment">// 第一次调用超类型继承</span></span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'jane'</span>, <span class="number">25</span>)</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>) </span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors) <span class="comment">// ['red', 'blue', 'black']</span></span><br><span class="line">instance.sayName() <span class="comment">// jane</span></span><br><span class="line">instance.sayAge()  <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<h2 id="原型式继承Object-create"><a href="#原型式继承Object-create" class="headerlink" title="原型式继承Object.create()"></a>原型式继承Object.create()</h2><blockquote>
<p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。只想让一个对象与另一个对象保持类型的情况下，原型式继承是完全可以做到的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<ul>
<li>在object函数内部，先创建来一个临时性的构造函数</li>
<li>然后传入的对象作为这个构造函数的原型，</li>
<li>最后返回来这个临时类型的一个新实例</li>
<li>object对传入其中的对象执行来了一次浅复制</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'jane'</span>,</span><br><span class="line">  colors: [<span class="string">'red'</span>, <span class="string">'black'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = object(person)</span><br><span class="line">anotherPerson.name = <span class="string">'symbol'</span></span><br><span class="line">anotherPerson.colors.push(<span class="string">'green'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = object(person)</span><br><span class="line">anotherPerson.name = <span class="string">'smiss'</span></span><br><span class="line">anotherPerson.colors.push(<span class="string">'orange'</span>)</span><br><span class="line"></span><br><span class="line">person.colors <span class="comment">// ['red', 'black', 'blue', 'green', 'orange']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用Object.create()相同</span></span><br><span class="line"><span class="comment"> * @params：</span></span><br><span class="line"><span class="comment"> *    第一个：用作新对象原型的对象</span></span><br><span class="line"><span class="comment"> *    第二个：新对象定义额外属性的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person)</span><br><span class="line">anotherPerson.name = <span class="string">'symbol'</span></span><br><span class="line">anotherPerson.colors.push(<span class="string">'green'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">'smiss'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">yetAnotherPerson.name <span class="comment">// 'smiss'</span></span><br></pre></td></tr></table></figure>

<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><blockquote>
<p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后再像真的是它做了所有工作一样返回对象。不能做到函数复用而降低效率，在主要考虑对象而不是自定义类型和构造函数的情况下使用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = object(origin)</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'jane'</span>,</span><br><span class="line">  colors: [<span class="string">'red'</span>, <span class="string">'black'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHi() <span class="comment">// 'hi'</span></span><br></pre></td></tr></table></figure>

<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><blockquote>
<p>组合继承最大的问题就在于无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。集寄生式继承和组合式继承的优点，是实现基于类型继承的最有效方式，只调用了一次超类型构造函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * inheritPrototype：寄生组合式继承</span></span><br><span class="line"><span class="comment"> * @params：子类型函数、超类型函数</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建超类型原型的一个副本</span></span><br><span class="line">  <span class="keyword">let</span> prototype = obejct(superType.prototype)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给副本添加constructor属性，弥补因重写原型而失去的默认的constructor属性</span></span><br><span class="line">  prototype.constructor = subType</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将副本赋值给子类型的原型</span></span><br><span class="line">  subType.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">'jane'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/11/17/js/闭包和作用域/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2019/02/12/mysql/basicCommands/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
